# 架构整理

## model
### db.go
链接数据库，新建表

这里新建了两张表，goods和order，对应下面两个go文件
### goods.go
一开头就创建一个结构体，定义商品的属性（包括grom.Model）

下面是该结构体的各种方法/函数，这种函数里面是SQL语句和判断if nil之类的。

添加信息用方法，查询信息用函数，里面的返回值都含有error
### order.go
这个也同理，一开头创建结构体，包括gorm.Model

接下来也是添加方法和查询函数。
## service
这个层开始引用model层里面的函数。
### goods.go
一开头新建一个goods结构体，除了用ID字段代替了原来的gorm.Model字段其他的字段都一样。

然后开始照例的函数，同样也是添加和查询商品。这里的添加有TODO。

但是查询函数，它一开始引用了model里面的查询函数，判断那个函数的error ！= nil，（其实它判断了两次nil，在model层是数据库是否有错就已经判断了次）
然后就是涉及到的其他一些非SQL、非JSON操作（遍历，返回一个good集）。
### order.go
这里没有重新定义结构体，可能是因为上面那个文件它返回的参数有一个good结构体，它需要提高一个符合上层需求的结构体。

这里同样调用model层的结构体赋值、方法，下单（上层传下了订单信息，放到下层存储）。
### sec_kill.gou
*划线，重点，我没看懂的都是重点？？？*

这里也有个TODO
## controller
这个层开始调用service层里的函数，但是不会调用model层的函数。
### goods.go
这个go文件里面只有一个函数，这个函数也就是main文件里面路由头用的那个函数。

这是一个查询商品的函数，同样的先调用service层里面的查询商品的函数，只是在这个基础上加了JSON。
### order.go
同理，这边的下订单的函数也是main文件路由头里面的函数。

这里它先读取了传参，然后？？？，最后JSON输出。

我去代码里面写注释了，感觉两条主线，一条是goods，另外条是order，order主线好像涉及到了一些奇怪的东西。
# 其他一些想记录的东西
上面的都是很之前写的。。。

刚才一开始我的消息队列因为存储参数，而我程序有问题，所以会导致一运行就不行。

后来改了，直接把生成queue的第三个参数设为自动删除。

但是在改的过程中，改了很多地方。

然后就出现了新问题，就是一个全局变量的map，它每次运行都会初始化，拒绝履行它作为全局变量的义务。

可是我又忘记改哪了。。。

（如果学长看的话估计看的到，没看的话我也好再摸摸鱼。）